<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <pre>
        엘리먼트란>?
        어떤 물체를 구성하는 성분 

        리액트에서의 엘리먼트도 리액트를 구성하는 요소를 의미한다.
        리액트앱을 구성하는 가장 작은 블록들

        돔엘리먼트와 리액트엘리먼트의 차이
        리액트엘리먼트는 돔엘리먼트의 가상표현이라고 볼수있따
        돔엘리먼트는 많은 정보를 담고있기때문에 상대적으로 크고 무겁다
        엘리먼트는 화면에서 보이는것들을 기술한다

        리액트 엘리먼트의 특징은 불변성이다.
        엘리먼트 생성 후에는 children이나 attributes를 바꿀 수 없다
    </pre>

    <pre>
        컴포넌트와 프롭스 (Components and Props)

        리액트는 컴포넌트 기반의 구조이다
        리액트의 모든 페이지는 컴포넌트로 구성되어있고 하나의 컴포넌트는 여러개의 하위 컴포넌트로 구성될 수 있따.
        마치 레고블록 조립하듯 새로운컴포넌트를 만들 수 있다.

        입력 > 리액트컴포넌트 > 출력 (기존의 자바스크립트 함수와 동작이 비슷하다)
        리액트 컴포넌트의 입력은 프롭스 / 출력이 리액트 엘리먼트이다
        Props > react component > react element


        Props = Property의 약자
        - 리액트에서의 프롭스는 속성을 의미한다
        - 컴포넌트에 전달할 다양한 정보를 담고 있는 자바스크립트 객체이다.
        - Read only , 즉 값을 변경할 수 없다. 같은 props에 대해서는 항상 같은 엘리먼트를 리턴해야한다.

        붕어빵을 예로 들면
        1. 붕어빵 틀이라는 '컴포넌트' 안에 
        2. 팥,고구마,슈크림등의 'Props'를 넣어서 
        3. 각각의 붕어빵'엘리먼트'들이 결과로 나오는것

        
        * 컴포넌트
        class Component(클래스 컴포넌트)
        - 자바스크립트ES6의 클래스라는 것을 사용해서 만들어진 형태의 컴포넌트이다.
        - React.component를 상속받아 만든다. ( 한 클래스의 변수들과 함수들을 상속받아 새로운 자식 클래스를 만드는 방법)

        - 생성자에서 state를 정의
        -setState()함수를 통해 state 업데이트
        -Lifecycle methods 제공
        
        function Component(함수 컴포넌트)
        - 코드가 간단하다. 

        - state 사용 불가 
        -Lifecycle에 따른 기능 구현 불가
        - 별도로 스테이트를 정의해서 사용하거나 컴포넌트의 생명주기에 맞춰 어떤 코드가 실행되도록 할수 없었다 > 그래서 HOOK을 사용한다!



        * 컴포넌트의 이름
        - Component 이름은 항상 대문자로 시작해야한다.
        소문자로 시작하는 컴포넌트는 돔태그라고 인식한다
        (div > div태그로 인식 / Welcome > Welcome이라는 컴포넌트로 인식)

        *component 렌더링
    </pre>

    <pre>
        State and LifeCycle

        State
        -리액트 컴포넌트의 상태(리액트 컴포넌트의 번경가능한 데이터)
        -개발자가 직접 정의한다
        -렌더링이나 데이터 흐름에 사용되는 값만 스테이트에 포함시켜야함
        (스테이트가 변경될 경우 컴포넌트가 재 렌더링되는데,
        재 렌더링이 필요없는 값을 스테이트에 포함시키면 불필요하게 재렌덜링이 일어나 성능을 저하시킬수있다.)
        - 자바스크립트 객체이다.
        - State는 수정할수없다 (수정해서 사용하는건 잘못된 사용법이다.)

        *LifeCycle (생명주기)
        - 리액트 컴포넌트의 생명주기이다.
        - component는 계속 존재하는 것이 아니라, 시간에 흐름에 따라 생성되고, 업데이트 되다가 사라진다.

        Mounting(출생) 
        constructor 생성자가 실행된다 (스테이트를 정의한다.)
        
        Updating (인생) 
        mounting부터 updating까지 컴포넌트가 렌더링되고
        (props가 변경되거나, setState에 함수 호출에 의해 스테이트가 변경되거나, forceUpdate 강제업데이트함수 호출에 의해 컴포넌트가 다시 렌더링된다.)
        이후에 componentDidUpdate가 일어난다.

        Unmounting(사망)
        상위컴포넌트에서 현재 컴포넌트를 더이상 화면에 표시하지않게 될때 언마운트된다고 볼수있다.
        Unmounting 직전에는 componentWillUnmount 함수가 호출된다.
    
    </pre>

    <pre>
        Hook (갈고리)
        - 프로그래밍에서는 원래 존재하는 어떤 기능에 마치 갈고리를 거는것처럼 끼어들어가 같이 실행되는걸 의미한다 (웹훅이라는 말과 비슷하다)
        
        -state관련함수,Lifecycle 관련함수, 최적화 관련 함수
        > 이러한 함수들을 HOOKs이라고 부른다
        > 이름은 use로 시작한다.
        > 커스텀훅도 만들어 사용할 수 있다(개발자가 자유롭게 만들수 있지만, 이름앞에 use를 붙여서 hook이라는걸 나타내줘야한다.)


        *useState
        >스테이트를 사용하기 위한 HOOK 
        <code> const [변수명, set함수명] = useState(초기값); <code>
        의 형태로 사용한다.
        -변수 각각에 대해 set 함수가 따로 존재한다.

        *useEffect
        side effect를 수행하기 위한 hook
        
        원래 프로그래밍에서의 side effect(부작용)는
        개발자가 의도치않은 코드가 실행되면서 버그가 나타나면 사이드이펙트가 발생햇다고 말한다.

        리엑트에서의 side effect는 효과,영향을 뜻하는 이펙트의 의미에 가깝다.
        서버에서 데이터를 받아오거나 수동으로 돔을 변경하는 등의 작업을 의미한다.
        이 작업들을 effect라고 부르는 이유는 
        다른컴포넌트에 영향을 미칠 수 있으며, 렌더링 중에는 작업이 완료될 수 없기때문이다.
        리액트의 함수 컴포넌트에서 side effect를 실행할 수 있게 해주는 hook이다.
        useEffect는 클래스컴포넌트에서의 componentDidMount,componentDidUpdate,componentWillUnmount 와 동일한 기능을 하나로 통합하여 제공한다.
        생명주기 함수와 동일한 기능을 수행 할 수 있다.


        <code>useEffect(이펙트 함수, 의존성 배열);</code>
        의 형태로 사용한다.
        의존성 배열은 이 이펙트가 의존하고 있는 배열인데, 배열안의 값이 하나라도 변경되었을때 이펙트함수가 실행된다.
        이펙트 함수는 처음 컴포넌트가 렌더링된 이후와 업데이트로 인한 재 렌더링 이후에 실행된다.

        이펙트 함수가 mount,unmount 시에 한번씩만 실행하게 하고싶으면
        <code>useEffect(이펙트함수,[])</code>
        와 같이 의존성 배열을 빈 배열로 넣어 주면 된다.
        해당 이펙트가 프랍스나 스테이트에 있는 어떤 값에도 의존하지 않는것이 됨으로 여러번 실행되지않는다.
        
        의존성배열을 생략할수도 있다
        <code>useEffect(이펙트함수);</code>
        의존성 배열을 생략하면 컴포넌트가 업데이트 될 때마다 호출된다.
        useEffect 안에서 return하는 함수는 컴포넌트가 unmount 될때 호출된다.
        (componentWillUnmount 함수의 역할과 동인하다)

        <code>
            useEffect(()=>{
                //컴포넌트가 마운트 된 이후,
                // 의존성 배열에 있는 변수들 중 하나라도 값이 변경되었을 때 실행됨
                // 의존성 배열에 빈 배열([])을 넣으면 마운트,언마운트시에 단 한번씩만 실행됨
                // 의ㅏ존성 배열 생략시 컴포넌트 업데이트 시마다 실행됨

                return()=>{
                    //컴포넌트가 마운트 해제되기 전에 실행됨
                }
            },[의존성 변수1, 의존성변수2, ...]);
        </code>

        *useMemo
        - Memoized value(메모이즈드 밸류)를 리턴하는 훅

        메모이제이션(Memoization)
        최적화를 위해 사용하는 개념
        비용이 높은, 즉 연산량이 많이 드는 함수의 결과를 저장해 두었다가 
        같은 입력값으로 함수를 호출하면 새로 호출하지않고, 이전에 저장해두었던 호출결과를 바로 반환하는것이다.
        (시간도 짧아지고, 불필요한 중복연산을 하지않는다.)
        
        메모이제이션된 결과값을 '메모이즈드 밸류'라고 부른다.

        <code>
            const memoizedValue = useMemo(
                ()=>{
                    //연산량이 높은 작업을 수행하여 결과를 반환
                    return computeExpensiveValue(의존선 변수, 의존성 변수2);
                },
                [의존성변수1, 의존성변수2]
            );
        </code>
        의 형태로 사용

        유즈메모훅은 파라메터로 메모이즈드밸류를 사용하는 크리에이트함수와, 의존성배열을 받는다.
        의존성배열에 들어있는 변수가 변했을경우 새로 크리에이트 함수를 호출하여 결과값을 반환하고, 그렇지 않은경우에는 기존함수의 결과값을 그대로 반환한다.
        = 컴포넌트가 다시 렌더링 될때마다 연산량이 높은 작업을 반복하는것을 피할 수 있다. (빠른렌더링 속도를 얻을 수 있다.)


        유즈메모로 전달된 함수는 렌더링이 일어나는동안 실행된다.
        렌더링이 일어나는 동안 실행되면 안될 작업을 유즈 메모 훅에 넣으면 안된다
        예를 들면 userEffect 훅에서 실행되어야할 사이드이펙트같은것
        서버에서 데이터를 받아오거나 수동으로 DOM을 변경해야할 떄 등의 작업은 렌더링이 될 동안 실행되면 안되기 때문에 userEffect 훅을 사용해야한다.




        <code>
            const memoizedValue = useMemo(
                ()=> computeExpensiveValue(a,b)
            );
        </code>
        의존성 배열을 넣지 않을경우, 매 렌더링마다 함수가 실행된다.
        따라서 유즈메모훅에 의존성배열을 넣지 않은경우는 아무런 의미가 없다.

        <code>
            const memoizedValue = useMemo(
                ()=> {
                    computeExpensiveValue(a,b)
                },[]
            );
        </code>
        의존성 배열이 빈배열일경우, 컴포넌트 마운트시에만 호출된다.
        마운트이후에는 값이 변경되지 않는다.
        (마운트시점에만 값을 계산하는경우)

        하지만 유즈메모훅은 
        대부분의 경우 유즈메모훅에 의존성배열에 변수를 넣고 해당 변수들의 값이 바뀜에 따라 새로 값을 계산해야할 경우에 사용한다.


        *useCallback 
        > useMemo 훅과 유사하지만, 값이 아닌 함수를 반환한다.
        <code>
            const  memoizedCallback = useCallback(
                ()=> {
                    doSomething(의존성변수1, 의존성변수2);
                },[의존성 변수1, 의존성변수2]
            );
        </code>
        유즈메모와 마찬가지로 함수와 의존성배열을 파라메터로 받는다.
        유즈콜백훅에서는 파라메터로 받는 이 함수를 콜백이라고 부른다
        의존성 배열애 변수들 중 하나라도 변경되면 메모이제이션된 콜백함수를 반환한다.

        *useRef
        레퍼런스(리액트에서의 특정 컴포넌트에 접근할 수 있는 객체)를 사용하기 위한 훅
        useRef 훅은 이 레퍼런스를 반환한다.

        refObject.current
        (레퍼런스 객체에 있는current 라는 속성 = 현재 참조하고 있는 Element)
        <code>
            const refContainer = useRef(초깃값);
        </code>
        파라메터로 초깃값을 넣으면 해당 초깃값으로 초기화된 레퍼런스 객체를 반환한다.
        초기값이 null이라면 커런트값이 널인 레퍼런스 객체가 반환된다
        이;렇게 반환된 레퍼런스 객체는 컴포넌트 생명주기 전체에 걸쳐 유지된다.
        변경 가능한 커런트라는 속성을 가진 하나의 상자이다.

        내부의 데이터가 변경되었을때 별도로 알리지않는다.
        즉 커런트 속성이 변경되었다고 재렌더링이 일어나지않는것
        ref에 돔노드가 연결되거나 분리되었을경우 어떤 코드를 실행하고 싶다면 callback ref를 사용해야한다.
        돔노드의 변화를 알기위한 가장 기초적인 방법으로 callback ref를 사용하는 방법이있다.
        리액트는 ref가 다른노드에 연결될때마다 콜백을 호출하게된다.
    </pre>


    <pre>
        hook으 ㅣ규칙
        1. 훅은 무조건 최상위 레벨에서만 호출해야한다.
        반복문의나 조건문, 중첩된 함수들안에서 훅을 호출하면안된다.
        훅은 컴포넌트가 렌더링될때마다 매번 같은 순서로 호출되어야한다


        2. 리액트 함수 컴포넌트에서만 훅을 호출해야한다.
        
    </pre>

    <pre>argument
        Handling Events

        Event란? 
        사건이라는 의미를 가지고 있다.
        사용자가 버튼을 클릭한 사건 = 버튼클릭이벤트

        DOM의 EVENT
        <button onclick="activate()"></button>


        react의 EVENT
        <button onClick={activate}></button>
            1. 온 클릭이 카멜케이스이다
            2. DOM에서는 함수를 문자열로 전달하지만, 리액트에서는 함수그대로 전달한다.


        Event 핸들러
        어떤사건이 발생하면 사건을 처리하는역할
        EVENT LISTENER라고 부르기도한다.


        아규먼트전달
        아규먼트 > 함수(이벤트핸들러)에 전달할 데이터  = 파라메터(매개변수)


        이벤트를 넣어줄때 this를 사용하지 않고 onClick에 곧바로 정희한 이벤트핸들러를 넘기면된다.\

        함수컴포넌트에서 이벤트 핸들러에 매개변수를 전달하는 방법
    </pre>

    <pre>
        Conditional Rendering

        Condition 조건,상태라는 뜻
        조건에 따른 렌더링 = 조건부 렌더링
        어떠한 조건에 따라 렌더링이 달라지는 것

        예를들면
        true이면 버튼을 보여주고 false이면 버튼을 가린다
    </pre>

    <pre>
       자바스크립트의   map()
        map()함수안에 있는 엘리먼트는 꼭 키값이 필요하다.

       const doubled = numbers.map((number)=> number*2)


       예제코드
        <code>
       const number = [1,2,3,4,5]
       const listItems = numbers.map((number)=>
            <li>{number}</li>
       );

       ReactDOM.render(
        <ul>{listItems}</ul>
        document.getElementById('root')
       );
    </code>
결과코드
<code>
    ReactDOM.render(
        <ul>
            <li>{1}</li>
            <li>{2}</li>
            <li>{3}</li>
            <li>{4}</li>
            <li>{5}</li>
        </ul>
        document.getElementById('root')
       );
</code>


기본적인 리스트컴포넌트

list의 key
키는 아이템들을 구분하기위한 고유한 문자열이다.
리액트에서의 키값은 같은 리스트에 있는 엘리먼트 사이에서만 고유한 값이면 된다,

고유한 키값을 사용하는 방법 

1. 키로 값을 사용하는 경우
<code>
    const number = [1,2,3,4,5]
    const listItems =numbers.map((number)=>
        <li key={number.toString()}>{number}</li>
    )
</code> > 넘버스배열에 숫자들이 중복되지않으면 문제가없지만, 중복된 숫자가 있다면 키값이 고유한값이 아니게 되기때문에 문제가 된다.

2. 키값으로 id를 사용하는경우
<code>
const todoItems = todos.map((todo)=>
    <li key={todo.id}>{todo.text}</li>
)
</code> > id라는것 자체가 고유한값이라는 것이기 때문에 키값으로 사용하기 적합하다/

3.key로 인덱스틀ㄹ 사용하는경우
code>
const todoItems = todos.map((todo)=>
    <li key={index}>{todo.text}</li>
)
</code>
> 아이템들의 고ㅓ유한 아이디가 없을경우에만 사용해야함
> 리액트에서는 키값을 명시적으로 넣어주지않으면 기본적으로 인덱스값을 키값으로 사용한다. 
> 맵함수에서 두번째 파라메터로 제공해주는 인덱스를 키값으로 사용한다. 가능하나 배열에서아이템의 순서가 바뀔수있는경우에는 키값으로 인덱스를 사용하는걸 권장하지않는다.


    </pre>

    <pre>
        form = 양식이라는 뜻을 가지고 있다.
        사용자로부터 입력을 받기 위해 사용
        
        Controlled Components
        상용자가 입력한갑에 접근하고 제어할수 있도록 해주는 컴포넌트이다
        값이 리액트의 통제를 받는 인풋 폼 엘리먼트이다.
        <select multiple={true} value="{['B','C']}"></select>

---------
        Uncontrolled Component
        file input 태그
        디바이스의 저장 장치로부터 하나 또는 여러개의 파일을 선택할수 있는 html 태그
        <input type="file" />
        = Uncontrolled Component가 된다. 값이 리액트의 통제를 받지 않는다는 의미
----------
        Multiple input
        여러개의 스테이트를 선언하여 각각의 입력에 대해 사용
        
        클래스 컴포넌트에서는 셋스테이트 함수 하나로 모든 스테이트의 값을 업데이트햇지만 
        함수컴포넌트에서는 각스테이트의 변수마다 셋 함수가 따로 존재하기 때문에 각각의 셋 함수를사용해서 구현하면된다
    
    
        인풋 널 밸류
        제어컴포넌트의 밸류프롭을 정해진 값으로 넣으면 
        코드를 수정하지않는 한 입력값을 바꿀 수없다
        밸류 프롭을 넣되 자유롭게 입력할 수 있게 만들고싶다면
        값에 언디파인드, 널을 넣으면된다

        <code>
            ReactDOM.render(<input value="hi" /> , rootNode);

            setTimeout(function(){
                ReactDOM.render(<input value={null} /> , rootNode)
            },1000);
        </code>
        퍼음에는 인풋의 값이 하이로 정해져있어서 값을 바꿀수없는 입력불가 상태였다가
        1초뒤에 밸류가 null인 인풋태그가 렌더링되면서 입력가능한 상태로 바뀐다.
        이렇게 하면 인풋에 밸류 프롭을 넣으면서 동시에 사용자가 값을 자유롭게 입력하게도 만들ㄹ 수 있다.
    </pre>

    <pre>

        ㅇ여러개의 컴포넌트들 사이에서 스테이트륽 공유하는 방ㅇ법

        Lifting State Up
        하위 컴포넌트의 state를 공통 상위 컴포넌트로 올림

        Shared State
        공유된 스테이트 , 자식컴포넌트들이 가장 가까운 공통된 붐ㅗ 컴포넌트의 스테이트를 공ㅇ유해서 사용하는것
        스테이트에 있는 데이터를 ㅇ여러개의 하위컴포넌트에서 공통적으로 사용하는 경ㅇ우


        부모컴포넌트의 state를 가져다가 사용하면된다.
    </pre>

    <pre>
        Composition vs Inheritance

        Composition(구성,'합성')
        여러개의 컴포넌틀를 합쳐 새로운 컴포넌트를 만드는 것

        에이라는 컴포넌트와 비라는 컴포넌트ㅏ 반복적으로 나온다.
        이 페이지는 컴포넌트 에이 비를 합쳐 페이지 컴포넌트를 만든것읻기 때문에 
        컴포지션, 즉 합성을 사용했다 볼수있따.
        

        컴포지션 사용기법

        1. Containment
        허위 컴포넌트를 포함하는 형태의 합성 방법
        sidebar나 dialog같은 박스형태의 컴포넌트는 자신의 하위 컴포넌트를 미리 알 수 없다.
        children이라는  prop을 사용해서 조합한다.
        해당 컴포넌트를 사용하는 개발자가 어떤것을 넣냐에 따라 하위 컴포넌트가 달라짐
        
        children prop을 사용한 FancyBorder컴포넌트
        <code>
            function FancyBorder(props){
                return(
                    <div className="{'fandyBorder FandyBorder-'}props.color">
                        {props.children}
                    </div>
                )
            }
        </code>

        FancyBorder 컴포넌트 안에 있는 모든 JSX 태그는 children으로 전달된다.
       <code>
        function WelcomeDialog(props){
            return(
                <FandyBorder color="blue">
                    <h1 className="Dialog-title">
                        어서오세요
                    </h1>
                    <p className="Dialog-message">
                        환영합니다.
                    </p>
                </FandyBorder>
            )
        }
       </code>


        Inheritance
    </pre>

    <pre>
        context
        기존에는 데이터가 컴포넌트의 프롭스를 통한 단방향으로(부모>자식) 데이터 전달
        이 방식은 여러 컴포넌트에 거쳐서 자주 사용되는 데이터(로그인정보 프로필정고)를
        반복적인 코드가 많이 생기고 지저분해진다.

        일일히 프롭스로 전달할 필요없이 데이터를 필요로하는 컴포넌트에 곧바로 데이터를 전달 할 수 있따.
        코드가 간결해지고 데이터를 한곳에서 관리하기 때문에 디버깅을 하기에도 유리해진다.

        context를 사용하는경우
        ㄷ른레벨의 많은 컴포넌트가 특정 데이터를 필요로 하는경우에 많이 사용한다.
        여러개의 컴포넌트들이 접근해야하는 데이터
        (로그인여부, 로그인정보, ui테마, 현재언어 등등...)
        x

        프로바이더의 모든 하위 컴포넌트가 컨텍스틍의 데이터를 읽을 수 있다.
        이렇게 사용하면 간결하고 직관적으로 변ㄱ한다.

        하지만 컨텍스트를 사용하면 컴포넌트의 재사용성이 떨어져서 꼭 필요한 경우가 아니라면 
        기존의 사용방법대로 상위컴포넌트에서 프롭스를 전달하는 컴포넌트 컴포지션 방법이 더 적합하다.


        context
        아바컴포넌트를 변수에 저장하여 직접 넘겨주는것
        이런식으로 하면 중간단ㄷ계에 있는 컴포넌트들은 유저와 아바타사이즈에 대해 몰라도된다.

        엘리먼트 베리어블형태

        유저와 아바타사이즈가 프롭스로 들어간 아바카 컴포넌트를 유저링크라는변수에 저장한뒤에 
        해당변수를 하위컴포넌트로 넘기고있다.

        이렇게하면 가장 상위 레벨의 페이지컴포넌트만 유저,아바타사이즈를 알고있으면된다.
        이러한방식은 중간레벨의 컴포넌ㅌ를 통해 전달해야하는 프롭스를 없애고 코드를간겨랗게 만든다;<div class="
        최상위"></div>
        최상위의 컴포넌트에 좀더 많은 권한을 부여해준다<div class="
        "></div>
        하지만 이러한 방식은 데이터가 많아질수록 상위 컴포넌트에 몰리기 때문에 상위컴포넌트는 너무 복잡해지고, 하위컴포넌트는 너무 유연해지게 된다.
        
        하위컴포넌트를 여러개의 변수로 나눠서 전달할 수도 있다.
         이 반식은 하위컴포넌트의 의존성을 ㄹㄹ상위 컴포넌트와 분리한 필요가 있는 대부분의 경우에 적합하다

         렌더링전에 하위>상위컴포넌트 통신의 경우 렌더프롭스를 사용하여 처리할 수도 있다면
         어떤경우에는 하나의 데이터에 다양한레벨에 있는 중첩된 컴포넌트들이 접근해야할 경우도 있다
         이러한 경우에는 context를 사용해야한다
         context는 해당 데이터와 데이터의 변경사항을 모두 하위컴포넌트에게 브로드캐스팅해준다
         (context를 사용하는 대표적인 예로는 현재 지역정보, 캐싱된 데이터, UI테마 등이있다)
    </pre>

    
    <pre>
        React.createContext()

        context생성
        const MyContext = React.creatContext(기본값);

        리액트에서 렌더링이 일어날떄 컨텍스트객체를 구독하는 하위컴포넌트가 나오면
        현재 컨텍스트의 값을 가장 가까이 있는 상위레벨의 프로바이더로부터 받아오게된다
        만약 상위레벨에 매칭되는 Provider가 없다면 이경우엔 기본값이 사용된다.
        기본값은 프로바이더없이 컴포넌트를 테스트할때 유용하다
        .
        기본값으로 undefined를 넣으면 기본값이 사용되지 않는다


        Context.Provieder

        Provider사용 
        <MyContext.Provider value="{/* some value */}">

        프로바이더 컴포넌트에는 value라는 프롭이 있다
        이것은 프로바이더 컴포넌틍= 하위에 있는 컴포넌트에 전달된다
        하위컴포넌트들이 데이ㅏ터를 소비한다는 의미에서 컨슈밍 컴포넌트라고 부른다
        프로바이더 컴포넌트로 감싸진 모든 컨슈밍컴포넌트들은 컨텍스트값의 변화를 지켜보다가 만약 값이 변경되면 재 렌더링된다
        하나의 프로바이더 컴포넌트는 여러개의 컨슈밍 컴포넌트들과연결될 수 있으며
        여러개의 프로바이더 컴포넌트는 중첩되어 사용할 수도 있다

        provider컴포넌트가 재렌더링될때마다 모든 하위 consumer컴포넌트가 재렌더링됨

        <code>
        function App(props){
            return(
                <MyContext.Provider value={{something:'something'}}>
                    <Toolbar />
                </MyContext.Provider>
            )
        };
    </code>


    state를 사용하여 불필요한 재렌더링을 막음
    <code>
        function App(props){
            const [value, setValue] = useState({something:'something'})
            return(
                <MyContext.Provider value={value}>
                    <Toolbar />
                </MyContext.Provider>
            )
        };
    </code>
    value를 직접 넣는게아니라 satat를 선언하고 스테이트의 값을 프로바이더에 넣었다



    Context.Consumer
    컨슈머 컴포넌트는 컨텍스트의 데이터를구독하는 컴포넌트이다

    <code>
        <MyContext.Consumer>
            {value => 컨텍스트의 값에 따라 컴포넌트들을 렌더링}
        </MyContext.Consumer>
    </code>
    컴텍스트점 컨슈머로 감싸면 자식으로 들어간 함수가 현재 컴텍스트의 밸ㄹ류를 받아서 리액트노드로 리턴한다
    함수로 전달되는 밸ㄹ류는 프로바이더의 밸류프롭과 동일하다

    
    function as a child
    컴포넌트의 자식으로 함수를 사용하는 방법
    <code>
        //children이라는 props을 직접 선언하는 방식
        <Profile children={name => <p>이름:{name}</p>} />

        //Profile컴포넌트로 감싸서 children으로 만드는 방식
        <Profile>{name => <p>이름:{name}</p>}</Profile>
    </code>
    

    useContext()
    <code>
        function MyComponent(props){
            const value = useContext(MyContext);

            return(
                ...
            )
        }
    </code>
    함수컨포넌트에서 컨슈머 매번 컴포넌트로 감싸주는것보다 유즈컨텍스트훅을 사용하면 쉽게 사용할수있따

    컨텍스트객체를 인자로 받아 현재 컨텍스트의 값을 리턴한다
    useContext훅을 사용하면 컨포넌트 트리상의 가장가까운 상위 프로바이더로부터 받아오게된다
    컨텍스트값이 변경되면 변경된 값과 함께 훅을ㄹ 사용하는 컴포넌트가 재 렌덜링된다

    그렇기때문에 훅을 사용하는 컨포넌트의 렌더링이 꽤 무거운 작업일 경우 별도로 최적화 작업이 필요하다


    
    파라메터로 컨텍스트 객체를 넣어줘야한다
    <code>
        //올바른사용방법
        useContext(MyContext);

        //잘못된사용방법
        useContext(MyContext.Consumer)
        useContext(MyContext.Provider)
    </code>
    </pre>
</body>
</html>
