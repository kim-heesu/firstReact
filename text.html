<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <pre>
        엘리먼트란>?
        어떤 물체를 구성하는 성분 

        리액트에서의 엘리먼트도 리액트를 구성하는 요소를 의미한다.
        리액트앱을 구성하는 가장 작은 블록들

        돔엘리먼트와 리액트엘리먼트의 차이
        리액트엘리먼트는 돔엘리먼트의 가상표현이라고 볼수있따
        돔엘리먼트는 많은 정보를 담고있기때문에 상대적으로 크고 무겁다
        엘리먼트는 화면에서 보이는것들을 기술한다

        리액트 엘리먼트의 특징은 불변성이다.
        엘리먼트 생성 후에는 children이나 attributes를 바꿀 수 없다
    </pre>

    <pre>
        컴포넌트와 프롭스 (Components and Props)

        리액트는 컴포넌트 기반의 구조이다
        리액트의 모든 페이지는 컴포넌트로 구성되어있고 하나의 컴포넌트는 여러개의 하위 컴포넌트로 구성될 수 있따.
        마치 레고블록 조립하듯 새로운컴포넌트를 만들 수 있다.

        입력 > 리액트컴포넌트 > 출력 (기존의 자바스크립트 함수와 동작이 비슷하다)
        리액트 컴포넌트의 입력은 프롭스 / 출력이 리액트 엘리먼트이다
        Props > react component > react element


        Props = Property의 약자
        - 리액트에서의 프롭스는 속성을 의미한다
        - 컴포넌트에 전달할 다양한 정보를 담고 있는 자바스크립트 객체이다.
        - Read only , 즉 값을 변경할 수 없다. 같은 props에 대해서는 항상 같은 엘리먼트를 리턴해야한다.

        붕어빵을 예로 들면
        1. 붕어빵 틀이라는 '컴포넌트' 안에 
        2. 팥,고구마,슈크림등의 'Props'를 넣어서 
        3. 각각의 붕어빵'엘리먼트'들이 결과로 나오는것

        
        * 컴포넌트
        class Component(클래스 컴포넌트)
        - 자바스크립트ES6의 클래스라는 것을 사용해서 만들어진 형태의 컴포넌트이다.
        - React.component를 상속받아 만든다. ( 한 클래스의 변수들과 함수들을 상속받아 새로운 자식 클래스를 만드는 방법)

        - 생성자에서 state를 정의
        -setState()함수를 통해 state 업데이트
        -Lifecycle methods 제공
        
        function Component(함수 컴포넌트)
        - 코드가 간단하다. 

        - state 사용 불가 
        -Lifecycle에 따른 기능 구현 불가
        - 별도로 스테이트를 정의해서 사용하거나 컴포넌트의 생명주기에 맞춰 어떤 코드가 실행되도록 할수 없었다 > 그래서 HOOK을 사용한다!



        * 컴포넌트의 이름
        - Component 이름은 항상 대문자로 시작해야한다.
        소문자로 시작하는 컴포넌트는 돔태그라고 인식한다
        (div > div태그로 인식 / Welcome > Welcome이라는 컴포넌트로 인식)

        *component 렌더링
    </pre>

    <pre>
        State and LifeCycle

        State
        -리액트 컴포넌트의 상태(리액트 컴포넌트의 번경가능한 데이터)
        -개발자가 직접 정의한다
        -렌더링이나 데이터 흐름에 사용되는 값만 스테이트에 포함시켜야함
        (스테이트가 변경될 경우 컴포넌트가 재 렌더링되는데,
        재 렌더링이 필요없는 값을 스테이트에 포함시키면 불필요하게 재렌덜링이 일어나 성능을 저하시킬수있다.)
        - 자바스크립트 객체이다.
        - State는 수정할수없다 (수정해서 사용하는건 잘못된 사용법이다.)

        *LifeCycle (생명주기)
        - 리액트 컴포넌트의 생명주기이다.
        - component는 계속 존재하는 것이 아니라, 시간에 흐름에 따라 생성되고, 업데이트 되다가 사라진다.

        Mounting(출생) 
        constructor 생성자가 실행된다 (스테이트를 정의한다.)
        
        Updating (인생) 
        mounting부터 updating까지 컴포넌트가 렌더링되고
        (props가 변경되거나, setState에 함수 호출에 의해 스테이트가 변경되거나, forceUpdate 강제업데이트함수 호출에 의해 컴포넌트가 다시 렌더링된다.)
        이후에 componentDidUpdate가 일어난다.

        Unmounting(사망)
        상위컴포넌트에서 현재 컴포넌트를 더이상 화면에 표시하지않게 될때 언마운트된다고 볼수있다.
        Unmounting 직전에는 componentWillUnmount 함수가 호출된다.
    
    </pre>

    <pre>
        Hook (갈고리)
        - 프로그래밍에서는 원래 존재하는 어떤 기능에 마치 갈고리를 거는것처럼 끼어들어가 같이 실행되는걸 의미한다 (웹훅이라는 말과 비슷하다)
        
        -state관련함수,Lifecycle 관련함수, 최적화 관련 함수
        > 이러한 함수들을 HOOKs이라고 부른다
        > 이름은 use로 시작한다.
        > 커스텀훅도 만들어 사용할 수 있다(개발자가 자유롭게 만들수 있지만, 이름앞에 use를 붙여서 hook이라는걸 나타내줘야한다.)


        *useState
        >스테이트를 사용하기 위한 HOOK 
        <code> const [변수명, set함수명] = useState(초기값); <code>
        의 형태로 사용한다.
        -변수 각각에 대해 set 함수가 따로 존재한다.

        *useEffect
        side effect를 수행하기 위한 hook
        
        원래 프로그래밍에서의 side effect(부작용)는
        개발자가 의도치않은 코드가 실행되면서 버그가 나타나면 사이드이펙트가 발생햇다고 말한다.

        리엑트에서의 side effect는 효과,영향을 뜻하는 이펙트의 의미에 가깝다.
        서버에서 데이터를 받아오거나 수동으로 돔을 변경하는 등의 작업을 의미한다.
        이 작업들을 effect라고 부르는 이유는 
        다른컴포넌트에 영향을 미칠 수 있으며, 렌더링 중에는 작업이 완료될 수 없기때문이다.
        리액트의 함수 컴포넌트에서 side effect를 실행할 수 있게 해주는 hook이다.
        useEffect는 클래스컴포넌트에서의 componentDidMount,componentDidUpdate,componentWillUnmount 와 동일한 기능을 하나로 통합하여 제공한다.
        생명주기 함수와 동일한 기능을 수행 할 수 있다.


        <code>useEffect(이펙트 함수, 의존성 배열);</code>
        의 형태로 사용한다.
        의존성 배열은 이 이펙트가 의존하고 있는 배열인데, 배열안의 값이 하나라도 변경되었을때 이펙트함수가 실행된다.
        이펙트 함수는 처음 컴포넌트가 렌더링된 이후와 업데이트로 인한 재 렌더링 이후에 실행된다.

        이펙트 함수가 mount,unmount 시에 한번씩만 실행하게 하고싶으면
        <code>useEffect(이펙트함수,[])</code>
        와 같이 의존성 배열을 빈 배열로 넣어 주면 된다.
        해당 이펙트가 프랍스나 스테이트에 있는 어떤 값에도 의존하지 않는것이 됨으로 여러번 실행되지않는다.
        
        의존성배열을 생략할수도 있다
        <code>useEffect(이펙트함수);</code>
        의존성 배열을 생략하면 컴포넌트가 업데이트 될 때마다 호출된다.
        useEffect 안에서 return하는 함수는 컴포넌트가 unmount 될때 호출된다.
        (componentWillUnmount 함수의 역할과 동인하다)

        <code>
            useEffect(()=>{
                //컴포넌트가 마운트 된 이후,
                // 의존성 배열에 있는 변수들 중 하나라도 값이 변경되었을 때 실행됨
                // 의존성 배열에 빈 배열([])을 넣으면 마운트,언마운트시에 단 한번씩만 실행됨
                // 의ㅏ존성 배열 생략시 컴포넌트 업데이트 시마다 실행됨

                return()=>{
                    //컴포넌트가 마운트 해제되기 전에 실행됨
                }
            },[의존성 변수1, 의존성변수2, ...]);
        </code>

        *useMemo
        - Memoized value(메모이즈드 밸류)를 리턴하는 훅

        메모이제이션(Memoization)
        최적화를 위해 사용하는 개념
        비용이 높은, 즉 연산량이 많이 드는 함수의 결과를 저장해 두었다가 
        같은 입력값으로 함수를 호출하면 새로 호출하지않고, 이전에 저장해두었던 호출결과를 바로 반환하는것이다.
        (시간도 짧아지고, 불필요한 중복연산을 하지않는다.)
        
        메모이제이션된 결과값을 '메모이즈드 밸류'라고 부른다.

        <code>
            const memoizedValue = useMemo(
                ()=>{
                    //연산량이 높은 작업을 수행하여 결과를 반환
                    return computeExpensiveValue(의존선 변수, 의존성 변수2);
                },
                [의존성변수1, 의존성변수2]
            );
        </code>
        의 형태로 사용

        유즈메모훅은 파라메터로 메모이즈드밸류를 사용하는 크리에이트함수와, 의존성배열을 받는다.
        의존성배열에 들어있는 변수가 변했을경우 새로 크리에이트 함수를 호출하여 결과값을 반환하고, 그렇지 않은경우에는 기존함수의 결과값을 그대로 반환한다.
        = 컴포넌트가 다시 렌더링 될때마다 연산량이 높은 작업을 반복하는것을 피할 수 있다. (빠른렌더링 속도를 얻을 수 있다.)


        유즈메모로 전달된 함수는 렌더링이 일어나는동안 실행된다.
        렌더링이 일어나는 동안 실행되면 안될 작업을 유즈 메모 훅에 넣으면 안된다
        예를 들면 userEffect 훅에서 실행되어야할 사이드이펙트같은것
        서버에서 데이터를 받아오거나 수동으로 DOM을 변경해야할 떄 등의 작업은 렌더링이 될 동안 실행되면 안되기 때문에 userEffect 훅을 사용해야한다.




        <code>
            const memoizedValue = useMemo(
                ()=> computeExpensiveValue(a,b)
            );
        </code>
        의존성 배열을 넣지 않을경우, 매 렌더링마다 함수가 실행된다.
        따라서 유즈메모훅에 의존성배열을 넣지 않은경우는 아무런 의미가 없다.

        <code>
            const memoizedValue = useMemo(
                ()=> {
                    computeExpensiveValue(a,b)
                },[]
            );
        </code>
        의존성 배열이 빈배열일경우, 컴포넌트 마운트시에만 호출된다.
        마운트이후에는 값이 변경되지 않는다.
        (마운트시점에만 값을 계산하는경우)

        하지만 유즈메모훅은 
        대부분의 경우 유즈메모훅에 의존성배열에 변수를 넣고 해당 변수들의 값이 바뀜에 따라 새로 값을 계산해야할 경우에 사용한다.


        *useCallback 
        > useMemo 훅과 유사하지만, 값이 아닌 함수를 반환한다.
        <code>
            const  memoizedCallback = useCallback(
                ()=> {
                    doSomething(의존성변수1, 의존성변수2);
                },[의존성 변수1, 의존성변수2]
            );
        </code>
        유즈메모와 마찬가지로 함수와 의존성배열을 파라메터로 받는다.
        유즈콜백훅에서는 파라메터로 받는 이 함수를 콜백이라고 부른다
        의존성 배열애 변수들 중 하나라도 변경되면 메모이제이션된 콜백함수를 반환한다.

        *useRef
        레퍼런스(리액트에서의 특정 컴포넌트에 접근할 수 있는 객체)를 사용하기 위한 훅
        useRef 훅은 이 레퍼런스를 반환한다.

        refObject.current
        (레퍼런스 객체에 있는current 라는 속성 = 현재 참조하고 있는 Element)
        <code>
            const refContainer = useRef(초깃값);
        </code>
        파라메터로 초깃값을 넣으면 해당 초깃값으로 초기화된 레퍼런스 객체를 반환한다.
        초기값이 null이라면 커런트값이 널인 레퍼런스 객체가 반환된다
        이;렇게 반환된 레퍼런스 객체는 컴포넌트 생명주기 전체에 걸쳐 유지된다.
        변경 가능한 커런트라는 속성을 가진 하나의 상자이다.

        내부의 데이터가 변경되었을때 별도로 알리지않는다.
        즉 커런트 속성이 변경되었다고 재렌더링이 일어나지않는것
        ref에 돔노드가 연결되거나 분리되었을경우 어떤 코드를 실행하고 싶다면 callback ref를 사용해야한다.
        돔노드의 변화를 알기위한 가장 기초적인 방법으로 callback ref를 사용하는 방법이있다.
        리액트는 ref가 다른노드에 연결될때마다 콜백을 호출하게된다.
    </pre>


    <pre>
        hook으 ㅣ규칙
        1. 훅은 무조건 최상위 레벨에서만 호출해야한다.
        반복문의나 조건문, 중첩된 함수들안에서 훅을 호출하면안된다.
        훅은 컴포넌트가 렌더링될때마다 매번 같은 순서로 호출되어야한다


        2. 리액트 함수 컴포넌트에서만 훅을 호출해야한다.
        
    </pre>

    <pre>argument
        Handling Events

        Event란? 
        사건이라는 의미를 가지고 있다.
        사용자가 버튼을 클릭한 사건 = 버튼클릭이벤트

        DOM의 EVENT
        <button onclick="activate()"></button>


        react의 EVENT
        <button onClick={activate}></button>
            1. 온 클릭이 카멜케이스이다
            2. DOM에서는 함수를 문자열로 전달하지만, 리액트에서는 함수그대로 전달한다.


        Event 핸들러
        어떤사건이 발생하면 사건을 처리하는역할
        EVENT LISTENER라고 부르기도한다.


        아규먼트전달
        아규먼트 > 함수(이벤트핸들러)에 전달할 데이터  = 파라메터(매개변수)


        이벤트를 넣어줄때 this를 사용하지 않고 onClick에 곧바로 정희한 이벤트핸들러를 넘기면된다.\

        함수컴포넌트에서 이벤트 핸들러에 매개변수를 전달하는 방법
    </pre>

    <pre>
        Conditional Rendering

        Condition 조건,상태라는 뜻
        조건에 따른 렌더링 = 조건부 렌더링
        어떠한 조건에 따라 렌더링이 달라지는 것

        예를들면
        true이면 버튼을 보여주고 false이면 버튼을 가린다
    </pre>

    <pre>
       자바스크립트의   map()
        map()함수안에 있는 엘리먼트는 꼭 키값이 필요하다.

       const doubled = numbers.map((number)=> number*2)


       예제코드
        <code>
       const number = [1,2,3,4,5]
       const listItems = numbers.map((number)=>
            <li>{number}</li>
       );

       ReactDOM.render(
        <ul>{listItems}</ul>
        document.getElementById('root')
       );
    </code>
결과코드
<code>
    ReactDOM.render(
        <ul>
            <li>{1}</li>
            <li>{2}</li>
            <li>{3}</li>
            <li>{4}</li>
            <li>{5}</li>
        </ul>
        document.getElementById('root')
       );
</code>


기본적인 리스트컴포넌트

list의 key
키는 아이템들을 구분하기위한 고유한 문자열이다.
리액트에서의 키값은 같은 리스트에 있는 엘리먼트 사이에서만 고유한 값이면 된다,

고유한 키값을 사용하는 방법 

1. 키로 값을 사용하는 경우
<code>
    const number = [1,2,3,4,5]
    const listItems =numbers.map((number)=>
        <li key={number.toString()}>{number}</li>
    )
</code> > 넘버스배열에 숫자들이 중복되지않으면 문제가없지만, 중복된 숫자가 있다면 키값이 고유한값이 아니게 되기때문에 문제가 된다.

2. 키값으로 id를 사용하는경우
<code>
const todoItems = todos.map((todo)=>
    <li key={todo.id}>{todo.text}</li>
)
</code> > id라는것 자체가 고유한값이라는 것이기 때문에 키값으로 사용하기 적합하다/

3.key로 인덱스틀ㄹ 사용하는경우
code>
const todoItems = todos.map((todo)=>
    <li key={index}>{todo.text}</li>
)
</code>
> 아이템들의 고ㅓ유한 아이디가 없을경우에만 사용해야함
> 리액트에서는 키값을 명시적으로 넣어주지않으면 기본적으로 인덱스값을 키값으로 사용한다. 
> 맵함수에서 두번째 파라메터로 제공해주는 인덱스를 키값으로 사용한다. 가능하나 배열에서아이템의 순서가 바뀔수있는경우에는 키값으로 인덱스를 사용하는걸 권장하지않는다.


    </pre>

    <pre>
        form = 양식이라는 뜻을 가지고 있다.
        사용자로부터 입력을 받기 위해 사용
        
        Controlled Components
        상용자가 입력한갑에 접근하고 제어할수 있도록 해주는 컴포넌트이다
        값이 리액트의 통제를 받는 인풋 폼 엘리먼트이다.
        <select multiple={true} value="{['B','C']}"></select>

---------
        Uncontrolled Component
        file input 태그
        디바이스의 저장 장치로부터 하나 또는 여러개의 파일을 선택할수 있는 html 태그
        <input type="file" />
        = Uncontrolled Component가 된다. 값이 리액트의 통제를 받지 않는다는 의미
----------
        Multiple input
        여러개의 스테이트를 선언하여 각각의 입력에 대해 사용
        
        클래스 컴포넌트에서는 셋스테이트 함수 하나로 모든 스테이트의 값을 업데이트햇지만 
        함수컴포넌트에서는 각스테이트의 변수마다 셋 함수가 따로 존재하기 때문에 각각의 셋 함수를사용해서 구현하면된다
    
    
        인풋 널 밸류
        제어컴포넌트의 밸류프롭을 정해진 값으로 넣으면 
        코드를 수정하지않는 한 입력값을 바꿀 수없다
        밸류 프롭을 넣되 자유롭게 입력할 수 있게 만들고싶다면
        값에 언디파인드, 널을 넣으면된다

        <code>
            ReactDOM.render(<input value="hi" /> , rootNode);

            setTimeout(function(){
                ReactDOM.render(<input value={null} /> , rootNode)
            },1000);
        </code>
        퍼음에는 인풋의 값이 하이로 정해져있어서 값을 바꿀수없는 입력불가 상태였다가
        1초뒤에 밸류가 null인 인풋태그가 렌더링되면서 입력가능한 상태로 바뀐다.
        이렇게 하면 인풋에 밸류 프롭을 넣으면서 동시에 사용자가 값을 자유롭게 입력하게도 만들ㄹ 수 있다.
    </pre>

    <pre>
        ㅇ여러개의 컴포넌트들 사이에서 스테이트륽 공유하는 방ㅇ법

        Lifting State Up
        하위 컴포넌트의 state를 공통 상위 컴포넌트로 올림

        Shared State
        공유된 스테이트 , 자식컴포넌트들이 가장 가까운 공통된 붐ㅗ 컴포넌트의 스테이트를 공ㅇ유해서 사용하는것
        스테이트에 있는 데이터를 ㅇ여러개의 하위컴포넌트에서 공통적으로 사용하는 경ㅇ우


        부모컴포넌트의 state를 가져다가 사용하면된다.
    </pre>

    <pre>
        Composition vs Inheritance

        Composition(구성,합성)
        여러개의 컴포넌틀를 합쳐 새로운 컴포넌트를 만드는 것

        Inheritance
    </pre>

</body>
</html>
